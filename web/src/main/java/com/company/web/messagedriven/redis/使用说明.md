# Redis 消息队列使用指南

## 快速开始

### 1. 配置启用

在 `application.yml` 中配置：

```yaml
# 启用 Redis 消息队列（三选一：redis / rabbitmq / rocketmq）
template:
  enable:
    message-driven: redis

# Redis 配置
spring:
  redis:
    host: 127.0.0.1
    port: 6379
    password: your_password  # 如果没有密码可留空
    database: 0
```

### 2. 发送消息示例

在 MqController 中已提供示例接口：

#### 发送普通消息
```bash
GET http://localhost:9010/mq/sendNormalMessage?message=hello
```

#### 发送广播消息
```bash
GET http://localhost:9010/mq/sendFanoutMessage?message=broadcast
```

#### 发送延时消息（30秒后执行）
```bash
GET http://localhost:9010/mq/sendDelayMessage?message=delay&delaySeconds=30
```

#### 发送 X-Delay 延时消息
```bash
GET http://localhost:9010/mq/sendXDelayMessage?message=xdelay&delaySeconds=30
```

### 3. 消费者示例

已实现的消费者：
- `CommonConsumer` - 公共队列消费者
- `XDelayConsumer` - 延时队列消费者  
- `FlashkillConsumer` - 秒杀队列消费者
- `OrderCreateConsumer` - 订单创建消费者

## 实现的组件

### Framework 层
```
framework/src/main/java/com/company/framework/messagedriven/redis/
├── RedisAutoConfiguration.java          # 自动配置类
├── RedisMessageSender.java              # 消息发送器
├── aspect/
│   └── TraceAspect.java                # 日志追踪切面
├── delay/
│   └── DelayQueueScanner.java          # 延时队列扫描器
├── gracefulshutdown/
│   └── RedisConsumerComponent.java     # 优雅下线组件
└── utils/
    └── ConsumerUtils.java              # 消费工具类
```

### Web 层
```
web/src/main/java/com/company/web/messagedriven/redis/
└── consumer/
    ├── CommonConsumer.java             # 公共消息消费者
    ├── FlashkillConsumer.java          # 秒杀消息消费者
    ├── OrderCreateConsumer.java        # 订单创建消费者
    └── XDelayConsumer.java             # 延时消息消费者
```

## 技术实现

### 消息发送
- **普通消息**: 使用 `RedisTemplate.convertAndSend()` 发送到 Pub/Sub 频道
- **延时消息**: 存储到 Sorted Set，使用时间戳作为 score
- **消息格式**: JSON 格式，包含 headers（策略名、类名、traceId）和 body

### 消息消费
- **普通消息**: 通过 `MessageListener` 监听 Pub/Sub 频道
- **延时消息**: 定时扫描器每秒扫描一次，将到期消息发布到频道
- **路由过滤**: 在消费者中根据 routing_key 过滤消息

### 核心特性
1. **统一接口**: 实现 `MessageSender` 接口，与 RabbitMQ/RocketMQ 接口一致
2. **策略模式**: 支持通过 Strategy 名称动态调用业务处理逻辑
3. **链路追踪**: 通过 TraceAspect 实现 MDC 日志追踪
4. **优雅下线**: 实现 ConsumerComponent 接口，支持优雅停机
5. **定时扫描**: 使用 `@Scheduled` 实现延时消息扫描

## 切换 MQ 类型

只需修改配置即可无缝切换：

```yaml
template:
  enable:
    message-driven: redis      # 可选：redis / rabbitmq / rocketmq / springevent
```

代码无需任何修改，所有消息发送和消费代码保持不变！

## 测试验证

1. 启动 Redis 服务
2. 启动 web 应用
3. 调用测试接口
4. 查看日志输出

延时消息测试：
```bash
# 发送延时消息（30秒后执行）
curl "http://localhost:9010/mq/sendXDelayMessage?message=test&delaySeconds=30"

# 等待 30 秒后，查看消费者日志
```

## 注意事项

1. ⚠️ Redis Pub/Sub 不保证消息持久化，服务重启消息会丢失
2. ⚠️ 适合对消息可靠性要求不高的场景
3. ⚠️ 延时消息精度为秒级（扫描间隔 1 秒）
4. ✅ 性能极高，适合高并发场景
5. ✅ 实现简单，无需额外部署 MQ 服务

## 适用场景

**推荐使用 Redis MQ**:
- 缓存失效通知
- 实时消息推送
- 轻量级任务队列
- 开发测试环境

**不推荐使用 Redis MQ**:
- 金融交易系统
- 订单支付系统
- 需要消息持久化的场景
- 需要消息确认机制的场景
